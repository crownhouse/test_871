<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DevAssist Maps V96 | phase 5</title>

    <link rel="stylesheet" href="css/CartoDB.css"/>
    <script src="js/CartoDB.js"></script>
    
    <link rel="stylesheet" href="https://labs.os.uk/public/os-api-branding/v0.3.0/os-api-branding.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <link rel="stylesheet" href="css/leaflet.draw.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-control-geocoder@1.13.0/dist/Control.Geocoder.css" />
    <link rel="stylesheet" href="css/leaflet.contextmenu.css"/> 
    
    <style>
        body { margin:0; padding:0; }
        #map { position:absolute; top:1; bottom:0; width:100%; height:96.5%}
        #header {background-color: rgb(0, 96, 135);height:40px; border: 3px solid grey; }

        #sB1 {position: absolute;  top: 130px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB2 {position: absolute;  top: 170px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB3 {position: absolute;  top: 210px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB4 {position: absolute;  top: 250px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB5 {position: absolute;  top: 290px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB6 {position: absolute;  top: 330px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB7 {position: absolute;  top: 370px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB8 {position: absolute;  top: 410px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB9 {position: absolute;  top: 450px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB10 {position: absolute;  top: 490px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB11 {position: absolute;  top: 530px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB12 {position: absolute;  top: 570px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB13 {position: absolute;  top: 610px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB14 {position: absolute;  top: 650px;  right: 10px;  padding: 10px;  z-index: 400;}
        #sB15 {position: absolute;  top: 690px;  right: 10px;  padding: 10px;  z-index: 400;}
        #rB1  {position: absolute;  top: 730px;  right: 10px;  padding: 10px;  z-index: 400;}

        #cB1 {
            position: absolute;
            top: 770px;      /* under Refresh (730px) */
            right: 10px;
            padding: 10px;
             z-index: 400;
            }

            .completeModeOn {
            background: #2e7d32;
            color: #ffffff;
                }
            /* Cursor while Complete Mode is active */
            .complete-cursor {
            cursor: crosshair !important;
            }


        #drawArrowBtn {
            cursor: pointer;
            background:  color: ##ffffff;
            border: 2px solid #c6c0ab ;
            padding: 0 10px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.2);
            width: 33px;
            height: 33px;
            border-radius: 4px;
            position: absolute;
            top: 315px;
            left: 10px;
            z-index: 400;
        }

        /* Button to trigger copying the double-click marker LngLat */
        #copyDblClickMarkerBtn {
            cursor: pointer;
            border: 2px solid #c6c0ab;
            padding: 0 10px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.2);
            height: 33px;
            border-radius: 4px;
            position: absolute;
            top: 360px;   /* as requested */
            left: 10px;
            z-index: 400;
            background: #ffffff;
        }

/* Subject button - same style as Save LngLat, positioned below it */
#subjectBtn {
    cursor: pointer;
    border: 2px solid #c6c0ab;
    padding: 0 10px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.2);
    height: 33px;
    border-radius: 4px;
    position: absolute;
    top: 440px;   /* below Save LngLat (360px) */
    left: 10px;
    z-index: 400;
    background: #ffffff;
}

/* ON state (similar idea to Complete button) */
.subjectModeOn {
    background: rgb(243, 10, 215) !important;
    color: #ffffff !important;
    border-color: rgb(243, 10, 215) !important;
}


/* Cursor while Subject Mode is active */
.subject-cursor {
    cursor: crosshair !important;
}



/* Subject Buffer button - same style, positioned below Subject */
#subjectBufferBtn {
    cursor: pointer;
    border: 2px solid #c6c0ab;
    padding: 0 10px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.2);
    height: 33px;
    border-radius: 4px;
    position: absolute;
    top: 480px;   /* below Subject (400px) */
    left: 10px;
    z-index: 400;
    background: #ffffff;
}

/* ON state (blue) */
.subjectBufferModeOn {
    background: rgb(42, 34, 233) !important;
    color: #ffffff !important;
    border-color: rgb(42, 34, 233) !important;
}


/*Subject Marker Button - same style, positioned below Subject */
#subjectMarkerBtn {
    cursor: pointer;
    border: 2px solid #c6c0ab;
    padding: 0 10px;
    box-shadow: 0 1px 5px rgba(0,0,0,0.2);
    height: 33px;
    border-radius: 4px;
    position: absolute;
    top: 520px;   /* below Subject Buffer (440px) */
    left: 10px;
    z-index: 400;
    background: #ffffff;
}



        /* Toast that shows "LngLat Saved" for 0.5s */
        #copyToast {
            position: absolute;
            top: 400px;        /* just below the button */
            left: 10px;
            padding: 8px 14px;
            background: #333;
            color: #fff;
            border-radius: 4px;
            font-size: 14px;
            opacity: 0;        /* hidden until shown */
            pointer-events: none;
            z-index: 9999;
        }
        
        .siteButtons:hover{opacity: 0.8;  cursor: pointer;}

/* Bottom-left multiplier control (vertical chips) */
.frame-multiplier-control {
  background: rgba(255,255,255,0.92);
  padding: 6px 6px;
  border-radius: 6px;
  box-shadow: 0 1px 5px rgba(0,0,0,0.25);
  border: 1px solid #c6c0ab;
  font-family: Arial, sans-serif;
  user-select: none;
}

.frame-multiplier-control .chip-row {
  display: flex;
  flex-direction: column;   /* ðŸ”¹ vertical stack */
  gap: 6px;
}

.frame-multiplier-control input[type="radio"] {
  display: none;
}

.frame-multiplier-control label {
  display: block;           /* full-width clickable */
  text-align: center;
  padding: 4px 10px;
  border-radius: 14px;
  border: 1px solid #c6c0ab;
  background: #ffffff;
  cursor: pointer;
  font-size: 12px;
  line-height: 1.2;
}

.frame-multiplier-control input[type="radio"]:checked + label {
  background: rgb(0, 96, 135);
  color: #ffffff;
  border-color: rgb(0, 96, 135);
}

/* Move the bottom-left multiplier control up slightly */
.leaflet-bottom.leaflet-left .frame-multiplier-control {
  margin-bottom: 36px;   /* ~30px up (tweak as needed) */
  margin-left: 6px;
}





    </style>
  
</head>

<body>
<style>
    /* Control.Geocoder.css overrides */
    .leaflet-control-geocoder-error {
        padding-bottom: 5px;
    }
    .leaflet-control-geocoder-alternatives {
        max-height: 300px;
        overflow: hidden;
        overflow-y: auto;
    }
    .leaflet-control-geocoder-alternatives li {
        white-space: normal;
    }

    #myCanvasElement {
        position: absolute;
        /* Let mouse events go through to reach the map underneath */
        pointer-events: none;
        /* Make sure to be above the map pane (.leaflet-pane) */
        z-index: 450;
    }
</style>

<div id="header">
    <img src="images/dalogo.png" height="40px" alt="da logo">
</div>

<div id="map"></div>

<button class="siteButtons" onclick="Action1()"  id="sB1"> Site 1 </button>
<button class="siteButtons" onclick="Action2()"  id="sB2"> Site 2 </button>
<button class="siteButtons" onclick="Action3()"  id="sB3"> Site 3 </button>
<button class="siteButtons" onclick="Action4()"  id="sB4"> Site 4 </button>
<button class="siteButtons" onclick="Action5()"  id="sB5"> Site 5 </button>
<button class="siteButtons" onclick="Action6()"  id="sB6"> Site 6 </button>
<button class="siteButtons" onclick="Action7()"  id="sB7"> Site 7 </button>
<button class="siteButtons" onclick="Action8()"  id="sB8"> Site 8 </button>
<button class="siteButtons" onclick="Action9()"  id="sB9"> Site 9 </button>
<button class="siteButtons" onclick="Action10()" id="sB10"> Site 10 </button>
<button class="siteButtons" onclick="Action11()" id="sB11"> Site 11 </button>
<button class="siteButtons" onclick="Action12()" id="sB12"> Site 12 </button>
<button class="siteButtons" onclick="Action13()" id="sB13"> Site 13 </button>
<button class="siteButtons" onclick="Action14()" id="sB14"> Site 14 </button>
<button class="siteButtons" onclick="Action15()" id="sB15"> Site 15 </button>

<button class="siteButtons" onclick="Action16()" id="rB1"> Refresh </button>

<button class="siteButtons" onclick="toggleCompleteMode()" id="cB1">
  Mark Complete
</button>



<button id="drawArrowBtn">></button>

<!-- New button to save LngLat of the double-click marker -->
<button id="copyDblClickMarkerBtn">Save LngLat</button>

<!-- New button to draw "Subject" boundary polygon -->
<button id="subjectBtn">Subject</button>
<button id="subjectBufferBtn">Subject Buffer</button>
<button id="subjectMarkerBtn">Subject Marker</button>



<canvas id="myCanvasElement"></canvas>

<!-- Toast message -->
<div id="copyToast">LngLat Saved</div>
    
<script src="https://labs.os.uk/public/os-api-branding/v0.3.0/os-api-branding.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>

<script src="js/leaflet.geometryutil.js"></script>
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.7.0/proj4.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/proj4leaflet/1.0.2/proj4leaflet.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<script src="https://labs.os.uk/public/assets/lib/Control.Geocoder.js"></script>

<script src="js/leaflet.contextmenu.js"></script>
<script src="js/leaflet-arrowheads.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>




<script>
    //variables for map
    var apiKey  = '0z6udDOAGss8GgMF21GoCXt8VfPVUueg';
    var serviceUrl = 'https://api.os.uk/maps/raster/v1/zxy';
    //variables for os postcode search 
    var apiKey2 = '0z6udDOAGss8GgMF21GoCXt8VfPVUueg';

    var nameServiceUrl = 'https://api.os.uk/search/names/v1',
        tileServiceUrl = 'https://api.os.uk/maps/raster/v1/zxy';

    // Setup the EPSG:27700 (British National Grid) projection.
    var crs = new L.Proj.CRS('EPSG:27700',
        '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 ' +
        '+ellps=airy +towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 +units=m +no_defs',
        {
            resolutions: [ 896.0, 448.0, 224.0, 112.0, 56.0, 28.0, 14.0, 7.0, 3.5, 1.75, 0.875, 0.4375, 0.21875, 0.109375, 0.054688],
            origin: [ -238375.0, 1376256.0 ]
        }
    );
   
    // Instantiate a tile layer object for the Leisure style (displayed at zoom levels 0-9).
    var leisure = L.tileLayer(serviceUrl + '/Leisure_27700/{z}/{x}/{y}.png?key=' + apiKey, {
        maxZoom: 14,
        maxNativeZoom: 13
    });

    // Instantiate a tile layer object for the Road style (displayed at zoom levels 10-13).
    var road = L.tileLayer(serviceUrl + '/Road_27700/{z}/{x}/{y}.png?key=' + apiKey, {
        maxZoom: 14,
        maxNativeZoom: 13,
        minZoom: 10
    });

    // Transform coordinates.
    var transformCoords = function(arr) {
        return proj4('EPSG:27700', 'EPSG:4326', arr).reverse();
    };

    // Initialize the map.
    var mapOptions = {
        crs: crs,
        layers: [ leisure, road ],
        minZoom: 0,
        maxZoom: 14,
        zoomSnap: 0.5,
        zoomDelta: 0.5,
        maxNativeZoom: 13,
        center: transformCoords([ 247692 , 55333]),
        zoom: 10,
        maxBounds: [
            transformCoords([ -238375.0, 0.0 ]),
            transformCoords([ 900000.0, 1376256.0 ])
        ],
        attributionControl: false,
        contextmenu: true,
        contextmenuWidth: 140,
        contextmenuItems: [{
            text: 'Show coordinates',
            callback: showCoordinates
        }, {
            text: 'Center map here',
            callback: centerMap
        }, '-', {
            text: 'Zoom in',
            icon: 'images/zoom-in.png',
            callback: zoomIn
        }, {
            text: 'Zoom out',
            icon: 'images/minus.png',
            callback: zoomOut
        }]
    };

    function showCoordinates (e) {
        alert(e.latlng);
    }
    function centerMap (e) {
        map.panTo(e.latlng);
    }
    function zoomIn (e) {
        map.zoomIn();
    }
    function zoomOut (e) {
        map.zoomOut();
    }

    var map = L.map('map', mapOptions);

    //canvas for print frame test
    var myCanvasElement = document.getElementById('myCanvasElement');

    // Adjust the canvas size, assuming we want to cover the entire map.
    var mapSize = map.getSize();
    myCanvasElement.width  = mapSize.x;
    myCanvasElement.height = mapSize.y;

    // Move the canvas inside the map container.
    var mapContainer = map.getContainer();
    mapContainer.appendChild(myCanvasElement);

// === Frame multiplier (default 1.0) ===
var frameMultiplier = 1.0;

// Create a Leaflet control bottom-left with "chips"
var FrameMultiplierControl = L.Control.extend({
  options: { position: 'bottomleft' },

  onAdd: function () {
    var container = L.DomUtil.create('div', 'frame-multiplier-control');
    container.innerHTML =
      '<div class="chip-row" id="frameMultChips"></div>';

    // Prevent clicks on the control from interacting with the map
    L.DomEvent.disableClickPropagation(container);
    L.DomEvent.disableScrollPropagation(container);

    // Build chip set: 1, 1.1 ... 2.2
    var values = [1,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2];
    var chips = container.querySelector('#frameMultChips');

    values.forEach(function(v, idx) {
      var id = 'fm_' + String(v).replace('.', '_');

      // Default selected = 1
      var checked = (v === 1) ? 'checked' : '';

      chips.insertAdjacentHTML('beforeend',
        '<input type="radio" name="frameMult" id="' + id + '" value="' + v + '" ' + checked + '>' +
        '<label for="' + id + '">' + (v % 1 === 0 ? v.toFixed(0) : v.toFixed(1)) + '</label>'
      );
    });

    // Listen for changes
    container.addEventListener('change', function(e) {
      if (e.target && e.target.name === 'frameMult') {
        frameMultiplier = parseFloat(e.target.value) || 1.0;

        // Redraw frame immediately using existing zoom logic
        map.fire('zoomend');
      }
    });

    return container;
  }
});

map.addControl(new FrameMultiplierControl());




    // Draw on the canvas...
    var context = myCanvasElement.getContext('2d');
    context.strokeStyle = 'rgb(99, 99, 99)';
    var w  = 1530;
    var w1 = 765;
    var w2 = 382;
    var w3 = w2 / 2;
    var h  = 2160;
    var h1 = 1080;
    var h2 = 540;
    var h3 = h2 / 2;
    var x  = (mapSize.x - w)  / 2;
    var x1 = (mapSize.x - w1) / 2;
    var x2 = (mapSize.x - w2) / 2;
    var x3 = (mapSize.x - w3) / 2;

    var y  = (mapSize.y - h)  / 2;
    var y1 = (mapSize.y - h1) / 2;
    var y2 = (mapSize.y - h2) / 2;
    var y3 = (mapSize.y - h3) / 2;

    var myRadius13 = 686;
    var myRadius12 = 343;
    var myRadius11 = 171.5;
  
    //variable for my icon 
    var LeafIcon = L.Icon.extend({
        options: {
            iconSize:  [51.7, 25.3],
            iconAnchor:[11, 46],
        }
    });

    var myIcon1  = new LeafIcon({iconUrl: 'images/s1.png'}),
        myIcon2  = new LeafIcon({iconUrl: 'images/s2.png'}),
        myIcon3  = new LeafIcon({iconUrl: 'images/s3.png'}),
        myIcon4  = new LeafIcon({iconUrl: 'images/s4.png'}),
        myIcon5  = new LeafIcon({iconUrl: 'images/s5.png'}),
        myIcon6  = new LeafIcon({iconUrl: 'images/s6.png'}),
        myIcon7  = new LeafIcon({iconUrl: 'images/s7.png'}),
        myIcon8  = new LeafIcon({iconUrl: 'images/s8.png'}),
        myIcon9  = new LeafIcon({iconUrl: 'images/s9.png'}),
        myIcon10 = new LeafIcon({iconUrl: 'images/s10.png'}),
        myIcon11 = new LeafIcon({iconUrl: 'images/s11.png'}),
        myIcon12 = new LeafIcon({iconUrl: 'images/s12.png'}),
        myIcon13 = new LeafIcon({iconUrl: 'images/s13.png'}),
        myIcon14 = new LeafIcon({iconUrl: 'images/s14.png'}),
        myIcon15 = new LeafIcon({iconUrl: 'images/s15.png'});

        //define myStyle
        var myStyle = {
            "color": "#f10200",
            "weight": 4,
            "opacity": 0.65
        };

    //add and remove rectangles when zooming    
map.on('zoomend', function () {
  context.clearRect(0, 0, mapSize.x, mapSize.y);

  var z = map.getZoom();

  // Only draw rec between zoom 10 and 12 (inclusive)
  if (z < 10 || z > 12) return;

  // Base size at zoom 10 (your existing zoom-10 rectangle)
  var baseW = w3;
  var baseH = h3;

  // Scale: +1 zoom => x2, +0.5 zoom => xâˆš2
 var scale = map.getZoomScale(z, 10);

  var ww = baseW * scale * frameMultiplier;
  var hh = baseH * scale * frameMultiplier;

  var xx = (mapSize.x - ww) / 2;
  var yy = (mapSize.y - hh) / 2;

  context.strokeRect(xx, yy, ww, hh);
});





    //adds drawn items layer 
    var drawnItems = new L.FeatureGroup().addTo(map);

    //adds site tags layer 
    var sitetagItems = new L.layerGroup().addTo(map);

    //adds my location layer (drawnoption custom marker hollow pin)
    var myLocation = new L.FeatureGroup().addTo(map);

// Subject boundary polygons (purple) - deletable
var subjectItems = new L.FeatureGroup().addTo(map);

// A single edit group Leaflet.draw will manage (so it can delete both kinds)
var editLayers = new L.FeatureGroup().addTo(map);



    let cartoData = L.layerGroup().addTo(map);

    var cirPin        = new L.FeatureGroup().addTo(map);
    var dblClickMarker = null; // store the marker created on double-click

    var customMarker = L.Icon.extend({
        options: {
            shadowUrl: null,
            iconAnchor: new L.Point(12, 20),
            iconSize:  new L.Point(15, 23.333),
            iconUrl:   'images/newpinhollow1.png'
        }
    });



// Subject buffer polygons (derived, not editable, not persisted)
var subjectBufferItems = new L.FeatureGroup().addTo(map);

var subjectBufferMode = false;

var subjectBufferStyle = {
  color: 'rgb(0, 0, 255)',
  weight: 3,
  opacity: 1,
  fill: false
};

// Build / rebuild the buffer layer from current subject polygons
function rebuildSubjectBuffer() {
  subjectBufferItems.clearLayers();

  // No subject polygons? nothing to buffer
  if (subjectItems.getLayers().length === 0) return;

  subjectItems.eachLayer(function(layer) {
    // buffer expects GeoJSON in WGS84
    var gj = layer.toGeoJSON();

    try {
      // 75m buffer
      var buff = turf.buffer(gj, 75, { units: 'meters' });

      // Add to map (non-interactive overlay)
      L.geoJSON(buff, {
        style: subjectBufferStyle,
        interactive: false
      }).eachLayer(function(l){
        subjectBufferItems.addLayer(l);
      });

    } catch (err) {
      console.log("Buffer failed:", err);
    }
  });
}

function toggleSubjectBufferMode() {
  subjectBufferMode = !subjectBufferMode;

  var btn = document.getElementById("subjectBufferBtn");

  if (subjectBufferMode) {
    btn.classList.add("subjectBufferModeOn");
    btn.innerText = "Subject Buffer: ON";
    rebuildSubjectBuffer();
  } else {
    btn.classList.remove("subjectBufferModeOn");
    btn.innerText = "Subject Buffer";
    subjectBufferItems.clearLayers();
  }
}

document.getElementById("subjectBufferBtn").onclick = toggleSubjectBufferMode;










    // ===== PLAN B: Complete Mode =====
var completeMode = false;

function styleByStatus(feature) {
  if (feature.properties && feature.properties.status === "complete") {
    return { color: "#00a000", weight: 4, opacity: 0.65 }; // green
  }
  return { color: "#f10200", weight: 4, opacity: 0.65 };   // red
}

function toggleCompleteMode() {
  completeMode = !completeMode;

  var btn = document.getElementById("cB1");
  var mapContainer = map.getContainer();

  if (completeMode) {
    btn.classList.add("completeModeOn");
    btn.innerText = "Complete Mode: ON";
    mapContainer.classList.add("complete-cursor");
  } else {
    btn.classList.remove("completeModeOn");
    btn.innerText = "Mark Complete";
    mapContainer.classList.remove("complete-cursor");
  }
}

function togglePolygonStatus(layer) {

  layer.status = (layer.status === "complete") ? "open" : "complete";

  // Update style immediately
  if (layer.status === "complete") {
    layer.setStyle({ color: "#00a000", weight: 5, opacity: 0.65 });
  } else {
    layer.setStyle({ color: "#f10200", weight: 5, opacity: 0.65 });
  }

  // Persist using SECURITY DEFINER function
  var geomJson = JSON.stringify(layer.toGeoJSON().geometry).replace(/'/g, "''");
var areaVal = (layer.feature && layer.feature.properties && layer.feature.properties.area)
  ? layer.feature.properties.area
  : 0;

var sql2 =
  "SELECT draw_items_upsert(" +
  "ARRAY[" + layer.cartodb_id + "]," +
  "ARRAY['" + geomJson + "']," +
  "ARRAY[" + areaVal + "]::numeric[]," +
  "ARRAY['" + layer.status + "']," +
  "ARRAY['']" +              // preserve fsrn_db
  ");";


  fetch(urlSmall, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: "q=" + encodeURI(sql2)
  })
  .then(r => r.json())
  .then(d => console.log("Status updated:", d))
  .catch(err => {
    console.log("Problem saving status:", err);
    alert("Failed to update status in database.");
  });
}


    
    //remove clear all option from delete dust bin 
    L.EditToolbar.Delete.include({
        removeAllLayers: false
    });
    
    //add drawing tools to map and default polygons to red once zoomed and circle to default to blue 
    map.drawControl = new L.Control.Draw({
        draw: {
            rectangle: false,
            polygon: {
                shapeOptions: {
                    color: 'red'
                },
                allowIntersection: false,
                drawError: {
                    color: 'orange',
                    timeout: 1000
                },
                showArea: true,
                metric: true,
                repeatMode: true
            },
            circlemarker:false,
            circle : false, 
            marker:{
                icon: new customMarker(1), 
                id: "myMK",
                class: "myClass"
            }
        },
        edit: {
    featureGroup: editLayers,
    remove: true
}
    });

    map.addControl(map.drawControl);

    let url = "https://geodcwh.xyz/sql?format=GeoJSON&q=";
    let urlSmall = "https://geodcwh.xyz/sql";

    let redIcon = L.icon({
        iconUrl:   "images/newpinhollow1.png",
        iconAnchor:[12, 20],
        iconSize:  [15, 23.333],
    });

    //dbl click to insert circle
    map.doubleClickZoom.disable(); 
    map.on('dblclick', function(e) {

        // Clear map
        myLocation.clearLayers();
        cirPin.clearLayers();
        
        let click = e.latlng;

        var circle = L.circle([click.lat, click.lng], {
            color: 'blue',
            radius: 75,
            fill: false,
        }).addTo(cirPin); 

        // store the marker so we can copy its lat,lng later
        dblClickMarker = L.marker(click, {icon: redIcon}).addTo(cirPin);
        
        // Set SQL query to add closest 50 polygons from drawn items 
        let sqlQueryClosest = 
            "SELECT cartodb_id, geom, name_lat, area, fsrn_db, status  FROM drawn_items " + 
            "ORDER BY (ST_Centroid(geom))::geography <-> ST_SetSRID(ST_MakePoint(" + 
            click.lng + "," + click.lat + 
            "), 4326)::geography LIMIT 50";

        // Get GeoJSON & add to map
        fetch(url + sqlQueryClosest)
            .then(function(response) {
                return response.json();
            })
            .then(function(data) {
                console.log(data);

               geojsonLayer = L.geoJson(data, {
  style: styleByStatus,

  onEachFeature: function (feature, layer) {

    layer.cartodb_id = feature.properties.cartodb_id;
    layer.status = feature.properties.status || "open";

    layer.bindPopup(
      "Area: " + feature.properties.area + " acres" +
      "<br>Report Ref: " + feature.properties.fsrn_db +
      "<br>Status: " + layer.status
    );

    layer.on("click", function () {
      if (!completeMode) return;
      togglePolygonStatus(layer);
    });

    myLocation.addLayer(layer);
    editLayers.addLayer(layer);
  }
});
 

                map.addLayer(myLocation);
            });
    });


function subjectAreaAcres(layer) {
  var rings = layer.getLatLngs();
  if (!rings || !rings.length) return 0;

  var outer = rings[0];
  var m2 = L.GeometryUtil.geodesicArea(outer);
  return m2 * 0.000247105; // mÂ² -> acres
}

function updateSubjectPopup(layer) {
  var acres = subjectAreaAcres(layer);
  var html = "<b>Subject Area</b><br>Area: " + acres.toFixed(2) + " acres";
  layer.bindPopup(html); // updates if already bound
}


    function persistOnCartoDB(action, layers) {
        var cartodb_ids = [];
        var geojsons    = [];
        var area_updates= [];
        var status_updates = [];
        var fsrn_updates = [];

        function calcArea(layer) {
            return (L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]) * 0.000247105).toFixed(2);
        }



        console.log(action + " persistOnCartoDB");




        switch (action) {

  case "UPDATE":
    if (!layers || layers.getLayers().length < 1) return;

    layers.eachLayer(function(layer) {
      cartodb_ids.push(layer.cartodb_id);
      geojsons.push("'" + JSON.stringify(layer.toGeoJSON().geometry) + "'");
      area_updates.push(calcArea(layer));

      // preserve existing values in DB
      status_updates.push("''");
      fsrn_updates.push("''");
    });
    break;

  case "DELETE":
    if (!layers || layers.getLayers().length < 1) return;

    layers.eachLayer(function(layer) {
      cartodb_ids.push(layer.cartodb_id);
      geojsons.push("''");     // empty -> NULL geom in your SQL function -> delete path
      area_updates.push("0");
      status_updates.push("''");
      fsrn_updates.push("''");
    });
    break;
}

     var sql2 = "SELECT draw_items_upsert(ARRAY[";
sql2 += cartodb_ids.join(",");
sql2 += "],ARRAY[";
sql2 += geojsons.join(",");
sql2 += "],ARRAY[";
sql2 += area_updates.join(",");
sql2 += "]::numeric[],ARRAY[";
sql2 += status_updates.join(",");
sql2 += "],ARRAY[";
sql2 += fsrn_updates.join(",");
sql2 += "]);";


        console.log("persisting... " + sql2);
        $.ajax({
            type: 'POST',
            url: 'https://geodcwh.xyz/sql',
            crossDomain: true,
            data: {
                "q": sql2
            },
            dataType: 'json',
            success: function(responseData, textStatus, jqXHR) {
                console.log("DB response:", responseData);
console.log("Rows:", responseData && responseData.rows);
                if (action === "INSERT" && responseData && responseData.rows && responseData.rows[0]) {

  var row = responseData.rows[0];

  // draw_items_upsert returns "(op,id)" e.g. "(1,45030)"
  if (row.draw_items_upsert) {
    var match = String(row.draw_items_upsert).match(/\(\s*-?\d+\s*,\s*(\d+)\s*\)/);
    if (match) {
      layers.cartodb_id = parseInt(match[1], 10);
      console.log("Stamped cartodb_id:", layers.cartodb_id);
    }
  }
}

            },
            error: function(responseData, textStatus, errorThrown) {
                console.log("Problem saving the data " + responseData);
            }
        });
    }

    // On draw - create editable popup - and deal with subject layers 
    map.addEventListener("draw:created", function(e) {
    var layer = e.layer;

    // If Subject Mode is ON, store polygon as subject boundary
    if (subjectMode && e.layerType === "polygon") {
        layer.isSubject = true;
        layer.setStyle(subjectStyle);

        updateSubjectPopup(layer);

        subjectItems.addLayer(layer);
        editLayers.addLayer(layer);     //  makes it deletable via draw toolbar

        // If you want to keep drawing multiple subject polygons while ON:
        if (subjectDrawer) {
          subjectDrawer.enable();
        }

        return; // IMPORTANT: don't run your normal drawn-items workflow
    }

    // Normal polygon workflow (old existing behaviour)
    drawnItems.addLayer(layer);
    editLayers.addLayer(layer);         // makes normal polygons deletable too
    createFormPopup();
});


    // On edit or delete - Close popup
    map.addEventListener("draw:editstart", function(e) {
        drawnItems.closePopup();
    });
    map.addEventListener("draw:deletestart", function(e) {
        drawnItems.closePopup();
    });


   // Persist edits after Leaflet.draw applies them (reliable event)
map.on("draw:edited", function(e) {
  var dbLayers = new L.LayerGroup();

  e.layers.eachLayer(function(layer) {
    if (layer.isSubject || layer.cartodb_id == null) return;
    dbLayers.addLayer(layer);
  });

  if (dbLayers.getLayers().length > 0) {
    persistOnCartoDB("UPDATE", dbLayers);
  }
});

// Update Subject polygon popup area after edits (no DB interaction)
map.on("draw:edited", function(e) {
  e.layers.eachLayer(function(layer) {
    if (layer.isSubject) {
      updateSubjectPopup(layer);
    }
  });
});




    map.on('draw:deleted', function (e) {
    drawnItems.closePopup();
    console.log("draw:deleted fired");

    // Split deleted layers into DB-backed vs local-only (subject)
    var dbLayers = new L.LayerGroup();

    e.layers.eachLayer(function(layer){
        // If it's a subject polygon OR has no cartodb_id, do NOT persist
        if (layer.isSubject || layer.cartodb_id == null) {
            // still remove from our groups
            subjectItems.removeLayer(layer);
            editLayers.removeLayer(layer);
            return;
        }

        // DB-backed polygon: send to persistence
        dbLayers.addLayer(layer);

        // also remove from groups locally
        myLocation.removeLayer(layer);
        editLayers.removeLayer(layer);
    });

    // Only call DB delete if there's something DB-backed
    if (dbLayers.getLayers().length > 0) {
        persistOnCartoDB("DELETE", dbLayers);
        console.log("DB delete persisted");
    }
});

    function addPopup2 (feature, layer) {
        layer.bindPopup(
            'New Drawn Area: ' + ("double click on pin to refresh") + ' acres' + 
            "<br>Report Ref: " + feature.properties.fsrn_db 
        );
    }

    // Create editable popup
    function createFormPopup() {
        let popupContent = 
            '<form>' + 
            'FSRN:<br><input type="text" id="input_fsrn"><br>' +
            '<input type="button" value="Submit" id="submit">' + 
            '</form>';
        drawnItems.bindPopup(popupContent).openPopup();
    }

    function setData(e) {
        if(e.target && e.target.id == "submit") {
            // Get user input fsrn
            let enteredFSRN = document.getElementById("input_fsrn").value;

            // For each drawn layer
            drawnItems.eachLayer(function(layer) {

                let seeArea  = L.GeometryUtil.geodesicArea(layer.getLatLngs()[0]);
                let seeArea2 = (seeArea * 0.000247105).toFixed(2);
               
                let drawing = JSON.stringify(layer.toGeoJSON().geometry).replace(/'/g, "''");

// Insert via SECURITY DEFINER function (cartodb_id < 0 triggers insert)
let sql =
  "SELECT draw_items_upsert(" +
  "ARRAY[-1]," +
  "ARRAY['" + drawing + "']," +
  "ARRAY[" + seeArea2 + "]::numeric[]," +
  "ARRAY['open']," +
  "ARRAY['" + enteredFSRN.replace(/'/g, "''") + "']" +
  ");";


                console.log(urlSmall + sql);

                let newData = layer.toGeoJSON();
newData.properties.fsrn_db = enteredFSRN;

// Add to map immediately 
var saved = L.geoJSON(newData, { onEachFeature: addPopup2, style: myStyle }).addTo(myLocation);
saved.eachLayer(function(l){ editLayers.addLayer(l); });

// remove the temporary drawn polygon from the delete/edit group
editLayers.removeLayer(layer);

fetch(urlSmall, {
  method: "POST",
  headers: { "Content-Type": "application/x-www-form-urlencoded" },
  body: "q=" + encodeURI(sql)
})
.then(function(response) { return response.json(); })
.then(function(data) {
  console.log("Data saved:", data);

  var newId = null;

  if (data && data.rows && data.rows[0]) {
    var row = data.rows[0];

    if (row.cartodb_id != null) {
      newId = parseInt(row.cartodb_id, 10);
    }

    if (!newId && row.draw_items_upsert) {
      var m = String(row.draw_items_upsert).match(/\(\s*-?\d+\s*,\s*(\d+)\s*\)/);
      if (m) newId = parseInt(m[1], 10);
    }
  }

  if (!newId) return;

  saved.eachLayer(function(l){
    l.cartodb_id = newId;
    l.status = "open";

    if (l.feature && l.feature.properties) {
      l.feature.properties.cartodb_id = newId;
      l.feature.properties.status = "open";
    }
  });
})
.catch(function(error) {
  console.log("Problem saving the data:", error);
});




            });

            drawnItems.closePopup();
            drawnItems.clearLayers();
        }
    }

    // Click on 'submit' event listener
    document.addEventListener("click", setData);

    //zooming changes existing polygon and circle properties
    map.on('zoomend', function() {
        map.drawControl.setDrawingOptions({
            polygon: {
                shapeOptions: {color: 'red', showArea: true, clickable: true}
            },
            circle: {
                shapeOptions: {color: 'blue', showArea: true, clickable: true, fill: false}
            }
        });
    });

    // Add geocoder control to the map.
    var geocoder = L.Control.geocoder({
        geocoder: new L.Control.Geocoder.osNamesAPI(apiKey),
        defaultMarkGeocode: false
    })
    .on('markgeocode', function(e) {
        var geocode = e.geocode;

        if( geocode.bbox ) {
            var projectedCoordsSW = transformCoords([ geocode.bbox._southWest.ea, geocode.bbox._southWest.no ]);
            var projectedCoordsNE = transformCoords([ geocode.bbox._northEast.ea, geocode.bbox._northEast.no ]);
            var bbox = L.latLngBounds(projectedCoordsSW, projectedCoordsNE);
            map.fitBounds(bbox);
        }
        else {
            var center = transformCoords([ geocode.center.ea, geocode.center.no ]);
            map.setView(center, 10);
        }
    })
    .addTo(map);

    //add zoom indicator 
    var ZoomViewer = L.Control.extend({
        onAdd: function(){
            var container= L.DomUtil.create('div');
            var gauge    = L.DomUtil.create('div');
            container.style.width       = '100px';
            container.style.background  = 'rgba(255,255,255,0.5)';
            container.style.textAlign   = 'left';
            map.on('zoomstart zoom zoomend', function(ev){
                gauge.innerHTML = 'Zoom level: ' + map.getZoom();
            })
            container.appendChild(gauge);
            return container;
        }
    });
    (new ZoomViewer).addTo(map);

// ===== Subject Mode (purple boundary polygon) =====
var subjectMode = false;
var subjectDrawer = null;

var subjectStyle = {
  color: 'rgb(243, 10, 215)',
  weight: 3,
  opacity: 0.65,
  fill: false
};

function toggleSubjectMode() {
  subjectMode = !subjectMode;

  var btn = document.getElementById("subjectBtn");
  var mapContainer = map.getContainer();

  if (subjectMode) {
    btn.classList.add("subjectModeOn");
    btn.innerText = "Subject: ON";
    mapContainer.classList.add("subject-cursor");

    // Start drawing a polygon immediately
    subjectDrawer = new L.Draw.Polygon(map, {
      shapeOptions: subjectStyle,
      allowIntersection: false,
      showArea: true,
      metric: true
    });
    subjectDrawer.enable();

  } else {
    btn.classList.remove("subjectModeOn");
    btn.innerText = "Subject";
    mapContainer.classList.remove("subject-cursor");

    // If currently drawing, disable
    if (subjectDrawer) {
      subjectDrawer.disable();
      subjectDrawer = null;
    }
  }
}

document.getElementById("subjectBtn").onclick = toggleSubjectMode;






</script>

<script>
    //function to add site markers on button click 
    function Action1(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon1,draggable:true}).addTo(sitetagItems);}
    function Action2(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon2,draggable:true}).addTo(sitetagItems);}
    function Action3(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon3,draggable:true}).addTo(sitetagItems);}
    function Action4(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon4,draggable:true}).addTo(sitetagItems);}
    function Action5(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon5,draggable:true}).addTo(sitetagItems);}
    function Action6(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon6,draggable:true}).addTo(sitetagItems);}
    function Action7(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon7,draggable:true}).addTo(sitetagItems);}
    function Action8(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon8,draggable:true}).addTo(sitetagItems);}
    function Action9(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon9,draggable:true}).addTo(sitetagItems);}
    function Action10(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon10,draggable:true}).addTo(sitetagItems);}
    function Action11(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon11,draggable:true}).addTo(sitetagItems);}
    function Action12(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon12,draggable:true}).addTo(sitetagItems);}
    function Action13(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon13,draggable:true}).addTo(sitetagItems);}
    function Action14(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon14,draggable:true}).addTo(sitetagItems);}
    function Action15(){var bounds = map.getBounds();var center = bounds.getCenter();L.marker([center.lat,center.lng], {icon: myIcon15,draggable:true}).addTo(sitetagItems);}
    function Action16(){
        sitetagItems.eachLayer(function(l){sitetagItems.removeLayer(l)});
        myLocation.eachLayer(function(aa){myLocation.removeLayer(aa)});
        drawnItems.eachLayer(function(ab){drawnItems.removeLayer(ab)});
        cartoData.eachLayer(function(bb){cartoData.removeLayer(bb)});
    }
</script>

<script>
    var drawingArrow = false;
    var arrowStart   = null;

    function startDrawingArrow() {
        drawingArrow = true;
        arrowStart   = null;
        map.once('click', function(e) {
            arrowStart = e.latlng;
            map.once('click', defineArrowEnd);
        });
    }

    function defineArrowEnd(e) {
        if (arrowStart) {
            var arrowEnd = e.latlng;
            var arrow = L.polyline([arrowStart, arrowEnd], {
                color: 'black',
                weight: 2
            });
            console.log(arrow);
            arrow.arrowheads({
                size: '8px',
                yawn: 60,
                fill: true,
                frequency: 'endonly',
                color: 'black'
            }).addTo(sitetagItems); // Add to sitetagItems
        }
        drawingArrow = false;
    }

    document.getElementById('drawArrowBtn').onclick = startDrawingArrow;

    // Show auto-closing toast (appears instantly, disappears after 0.5s)
    function showCopyToast() {
        var t = document.getElementById("copyToast");
        t.style.opacity = "1";

        setTimeout(function () {
            t.style.opacity = "0";
        }, 500); // hide after 0.5 seconds
    }

    // Copy the lat,lng of the double-click marker into the clipboard
    function copyDblClickMarkerLatLng() {
        if (!dblClickMarker) {
            alert("No marker found.\nDouble-click on the map to place the marker first.");
            return;
        }

        var pos = dblClickMarker.getLatLng();
        var text = pos.lat.toFixed(6) + ", " + pos.lng.toFixed(6);

        // Modern clipboard API
        if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(text)
                .then(function () {
                    showCopyToast();  // SUCCESS
                })
                .catch(function (err) {
                    console.error("Clipboard write failed", err);
                    alert("Copy failed, please copy this manually:\n" + text);
                });
        } 
        else {
            // Older browser fallback
            var temp = document.createElement("textarea");
            temp.value = text;
            temp.style.position = "fixed";
            temp.style.top = "-9999px";
            document.body.appendChild(temp);
            temp.select();

            try {
                document.execCommand("copy");
                showCopyToast(); // SUCCESS
            } 
            catch (e) {
                console.error("Fallback copy failed", e);
                alert("Copy failed, please copy this manually:\n" + text);
            }

            document.body.removeChild(temp);
        }
    }

    document.getElementById('copyDblClickMarkerBtn').onclick = copyDblClickMarkerLatLng;



function dropSubjectMarkerAtCenter() {
    var center = map.getBounds().getCenter();

    L.marker([center.lat, center.lng], {
        icon: redIcon,
        draggable: true
    }).addTo(sitetagItems);
}

document.getElementById("subjectMarkerBtn").onclick = dropSubjectMarkerAtCenter;




    
</script>

</body>
</html>
